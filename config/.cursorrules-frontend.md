# Frontend Development Rules

You are a frontend specialist working exclusively on the Next.js/React/TypeScript application in the `frontend/` directory.

## Scope & Boundaries

- **ONLY work in**: `frontend/` directory
- **NEVER modify**: `backend/`, `scripts/`, `prisma/`, `sql/`, or any Python files
- **If backend changes needed**: Create a comment or TODO, do NOT modify backend code

## Technology Stack

- **Framework**: Next.js 16 (App Router)
- **React**: 19.2.0
- **TypeScript**: Strict mode enabled
- **Styling**: Tailwind CSS 4
- **UI Components**: Shadcn UI, Radix UI
- **State Management**: 
  - Client state: Zustand (`@/store/`)
  - Server state: TanStack Query (`@tanstack/react-query`)
- **Charts**: Recharts
- **Icons**: Lucide React
- **Date handling**: date-fns

## Code Style & Structure

### File Organization
- Components: `components/` directory
  - Charts: `components/charts/`
  - Layout: `components/layout/`
  - UI: `components/ui/`
- Pages: `app/` directory (App Router)
- Utilities: `lib/` directory
- Store: `store/` directory

### Naming Conventions
- Components: PascalCase (e.g., `BarChart.tsx`, `CustomersPage.tsx`)
- Utilities: camelCase (e.g., `api.ts`, `utils.ts`)
- Directories: lowercase with dashes (e.g., `customer-behavior/`)

### TypeScript
- Use interfaces over types
- No `any` type - use explicit types
- All functions must have return types
- Use strict mode (already enabled in tsconfig.json)

## Next.js App Router Patterns

### Server vs Client Components
- **Default to Server Components** (no 'use client')
- **Use 'use client' ONLY when**:
  - Using React hooks (useState, useEffect, etc.)
  - Using browser APIs
  - Using event handlers
  - Using TanStack Query hooks
  - Using Zustand store

### Data Fetching
- Use TanStack Query for all API calls
- Include filter params in query keys for proper cache invalidation
- Always handle loading and error states
- Use `useQuery` hook pattern:
```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ["resource", "endpoint", filters],
  queryFn: () => apiFunction(filters),
});
```

### API Integration
- All API calls go through `lib/api.ts`
- Use the existing API functions (e.g., `customersAPI.demographics()`)
- Never hardcode API URLs - use `NEXT_PUBLIC_API_URL` env var
- Handle errors gracefully with try/catch or error boundaries

## Component Patterns

### Page Components
- Located in `app/(dashboard)/[route]/page.tsx`
- Use default export
- Fetch data with TanStack Query
- Pass data to presentational components

### Chart Components
- Located in `components/charts/`
- Accept data as props
- Use Recharts for visualization
- Make responsive with Tailwind classes

### UI Components
- Use Shadcn UI components from `components/ui/`
- Extend with Tailwind classes
- Follow existing component patterns

## State Management

### Zustand Store
- Store location: `store/`
- Use for global client state (filters, UI state)
- Pattern:
```typescript
import { create } from 'zustand';

interface FilterStore {
  filters: UniversalFilter;
  setFilters: (filters: UniversalFilter) => void;
}

export const useFilterStore = create<FilterStore>((set) => ({
  filters: {},
  setFilters: (filters) => set({ filters }),
}));
```

### TanStack Query
- Use for all server state
- Always include filters in query keys
- Use `queryKey` arrays: `["resource", "endpoint", filters]`

## Styling Guidelines

### Tailwind CSS
- Use utility classes
- Mobile-first responsive design
- Use existing design tokens (colors, spacing)
- Follow existing patterns in the codebase

### Responsive Design
- Use Tailwind breakpoints: `sm:`, `md:`, `lg:`, `xl:`
- Grid layouts: `grid grid-cols-1 lg:grid-cols-2`
- Spacing: Consistent use of `gap-6`, `space-y-6`, etc.

## Error Handling

- Always handle loading states (`isLoading`)
- Always handle error states (`error`)
- Use error boundaries for component-level errors
- Display user-friendly error messages
- Never show raw error objects to users

## Performance

- Minimize 'use client' directives
- Use Server Components when possible
- Lazy load heavy components
- Optimize images (if using Next.js Image component)
- Memoize expensive computations with `useMemo`

## Testing Considerations

- Components should be testable
- Avoid side effects in render functions
- Use dependency injection for API calls (via props or context)

## Common Patterns

### Filter Usage
```typescript
const { filters } = useFilterStore();

const { data } = useQuery({
  queryKey: ["resource", "endpoint", filters],
  queryFn: () => apiFunction(filters),
});
```

### Data Safety
```typescript
const data = Array.isArray(apiData?.data) ? apiData.data : [];
```

### Card Layout
```typescript
<Card>
  <CardHeader>
    <CardTitle>Title</CardTitle>
  </CardHeader>
  <CardContent>
    {/* Content */}
  </CardContent>
</Card>
```

## Import Paths

- Use `@/` alias for imports from root
- Example: `import { customersAPI } from "@/lib/api";`

## Environment Variables

- Use `NEXT_PUBLIC_` prefix for client-side env vars
- Access via `process.env.NEXT_PUBLIC_API_URL`

## DO NOT

- ❌ Modify backend code
- ❌ Use `any` type
- ❌ Create components without TypeScript interfaces
- ❌ Hardcode API URLs
- ❌ Skip loading/error states
- ❌ Use 'use client' unnecessarily
- ❌ Mutate Zustand state directly (use actions)
- ❌ Forget to include filters in query keys
```

```markdown:.cursorrules-backend.md
# Backend Development Rules

You are a backend specialist working exclusively on the FastAPI/Python application in the `backend/` directory.

## Scope & Boundaries

- **ONLY work in**: `backend/` directory
- **NEVER modify**: `frontend/`, `scripts/`, `prisma/`, `sql/`, or any TypeScript/JavaScript files
- **If frontend changes needed**: Document API changes, do NOT modify frontend code

## Technology Stack

- **Framework**: FastAPI 0.104.0+
- **Python**: 3.11+
- **Database**: PostgreSQL 16 (via psycopg2)
- **Validation**: Pydantic 2.0+
- **Async**: asyncio, async/await patterns
- **Connection Pooling**: psycopg2 ThreadedConnectionPool

## Code Style & Structure

### File Organization
- Main app: `app/main.py`
- API routes: `app/api/v1/`
- Schemas: `app/schemas/`
- Utilities: `app/utils/`
- Database: `app/database.py`
- Config: `app/config.py`

### Naming Conventions
- Files: snake_case (e.g., `customer_behavior.py`)
- Functions: snake_case (e.g., `get_customer_demographics`)
- Classes: PascalCase (e.g., `Database`, `Settings`)
- Constants: UPPER_SNAKE_CASE

### Python Type Hints
- **REQUIRED**: All functions must have type hints
- Use Pydantic models for request/response validation
- Explicit return types: `async def function() -> ResponseModel:`
- No `Any` type - use specific types or `Union`/`Optional`
- Use `from typing import Optional, List, Dict, Union`

## FastAPI Patterns

### Router Structure
- Each domain has its own router in `app/api/v1/`
- Routers are included in `main.py` with prefixes
- Use tags for OpenAPI documentation

### Endpoint Pattern
```python
@router.get("/endpoint", response_model=AnalyticsResponse)
async def get_endpoint(
    filters: UniversalFilter = Depends(get_filters),
):
    """Endpoint description."""
    where_clause, params = build_where_clause(filters)
    
    query = """
        SELECT ...
        FROM table
        WHERE {where_clause}
    """
    
    results = db.execute_query(query, tuple(params))
    
    return AnalyticsResponse(
        data=results,
        metadata={"count": len(results)},
        filters_applied=filters,
    )
```

### Dependencies
- Use FastAPI `Depends()` for dependency injection
- Common dependencies in `app/api/dependencies.py`
- Filter parsing: `get_filters` dependency

## Database Patterns

### Connection Management
- Use `Database` class from `app/database.py`
- Access via `db.execute_query(query, params)`
- Always use parameterized queries (never string formatting)
- Use context managers for transactions

### Query Patterns
- Use `build_where_clause()` from `app/utils/filters.py`
- Always use parameterized queries to prevent SQL injection
- Handle NULL values explicitly with `IS NULL` checks
- Use JOINs instead of N+1 queries

### Example Query
```python
where_clause, params = build_where_clause(filters)

query = f"""
    SELECT 
        column1,
        column2,
        COUNT(*) as count
    FROM table t
    WHERE {where_clause}
    GROUP BY column1, column2
    ORDER BY count DESC
    LIMIT 100
"""

results = db.execute_query(query, tuple(params))
```

## Pydantic Models

### Request/Response Models
- Located in `app/schemas/`
- Use for all API request/response validation
- Inherit from `BaseModel`
- Use field validators when needed

### Example Schema
```python
from pydantic import BaseModel
from typing import Optional

class UniversalFilter(BaseModel):
    branch_id: Optional[str] = None
    date_from: Optional[str] = None
    date_to: Optional[str] = None
    # ... other fields
```

## Error Handling

### Exception Handling
- Use FastAPI's `HTTPException` for API errors
- Global exception handler in `main.py`
- Log errors appropriately
- Return user-friendly error messages
- Never expose internal errors to clients

### Error Response Pattern
```python
from fastapi import HTTPException

if not result:
    raise HTTPException(
        status_code=404,
        detail="Resource not found"
    )
```

## Async/Await

### All Endpoints Must Be Async
- Use `async def` for all route handlers
- Use `await` for database operations
- Use async context managers when available

### Database Operations
- Database class handles async connection pooling
- Use `db.execute_query()` which is thread-safe
- Don't block the event loop

## API Response Format

### Standard Response
All endpoints return `AnalyticsResponse`:
```python
return AnalyticsResponse(
    data=results,  # The actual data
    metadata={"count": len(results)},  # Additional metadata
    filters_applied=filters,  # Applied filters
)
```

### Response Model
```python
class AnalyticsResponse(BaseModel):
    data: Any
    metadata: Dict[str, Any] = {}
    filters_applied: UniversalFilter
    timestamp: Optional[str] = None
    cache_ttl: Optional[int] = None
```

## Filter Handling

### Universal Filter
- All endpoints accept `UniversalFilter` via dependency injection
- Use `build_where_clause()` to convert filters to SQL
- Handle date ranges, branch filters, sales person filters, etc.
- Always validate filter inputs

### Filter Building
```python
from ...utils.filters import build_where_clause

where_clause, params = build_where_clause(filters)
# where_clause: "column1 = %s AND column2 = %s"
# params: ["value1", "value2"]
```

## Configuration

### Settings
- Use Pydantic Settings from `app/config.py`
- Access via `settings.database_url`, `settings.cors_origins`, etc.
- Environment variables loaded from `.env`

### CORS
- Configured in `main.py`
- Uses `settings.cors_origins`
- Allows credentials

## Logging

- Use Python's `logging` module
- Configure appropriate log levels
- Log errors, warnings, and important operations
- Don't log sensitive data (passwords, tokens)

## Testing Considerations

- Endpoints should be testable
- Use dependency injection for testability
- Mock database connections in tests
- Test error cases

## Performance

### Database Optimization
- Use indexes on frequently queried columns
- Avoid N+1 queries (use JOINs)
- Use LIMIT clauses for large result sets
- Consider pagination for large datasets

### Query Optimization
- Use EXPLAIN ANALYZE to optimize queries
- Avoid SELECT * when possible
- Use appropriate JOIN types
- Index foreign keys

## Security

### SQL Injection Prevention
- **ALWAYS** use parameterized queries
- **NEVER** use string formatting for SQL
- Use `build_where_clause()` utility

### Input Validation
- Use Pydantic models for validation
- Validate all user inputs
- Sanitize filter parameters

## Common Patterns

### Router Definition
```python
from fastapi import APIRouter

router = APIRouter()

@router.get("/endpoint")
async def endpoint():
    ...
```

### Database Query
```python
from ...database import db

query = "SELECT * FROM table WHERE id = %s"
results = db.execute_query(query, (id_value,))
```

### Response Building
```python
return AnalyticsResponse(
    data=results,
    metadata={"count": len(results)},
    filters_applied=filters,
)
```

## DO NOT

- ❌ Modify frontend code
- ❌ Use string formatting for SQL queries
- ❌ Skip type hints
- ❌ Use synchronous database operations
- ❌ Expose internal errors to clients
- ❌ Hardcode configuration values
- ❌ Create endpoints without Pydantic validation
- ❌ Forget to handle NULL values in queries
- ❌ Create N+1 query problems
- ❌ Skip error handling
```

```markdown:.cursorrules
# Global Cursor Rules for Data Analytics V5

This workspace contains a full-stack analytics application with separate frontend and backend codebases.

## Project Structure

- **Frontend**: Next.js 16 + React 19 + TypeScript in `frontend/`
- **Backend**: FastAPI + Python in `backend/`
- **Database**: PostgreSQL 16 (Prisma schema in `prisma/`)
- **Scripts**: Data processing scripts in `scripts/`

## Multi-Agent Workflow

When using multiple agents:

1. **Frontend Agents** should reference `.cursorrules-frontend.md`
2. **Backend Agents** should reference `.cursorrules-backend.md`
3. **Each agent should stay in their domain** - no cross-boundary modifications

## Agent Specialization

### Frontend Agents
- Focus: UI components, data visualization, client-side logic
- Directory: `frontend/`
- Never modify: `backend/`, `scripts/`, `prisma/`, `sql/`

### Backend Agents
- Focus: API endpoints, database queries, business logic
- Directory: `backend/`
- Never modify: `frontend/`, `scripts/`, `prisma/`, `sql/`

## Coordination

If agents need to coordinate:
- Use code comments: `// TODO: Backend needs to add /api/endpoint`
- Document API changes in commit messages
- Update API documentation when endpoints change

## General Rules

- Follow existing code patterns
- Maintain type safety (TypeScript strict, Python type hints)
- Handle errors gracefully
- Write testable code
- Document complex logic
```

