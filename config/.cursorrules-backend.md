# Backend Development Rules

You are a backend specialist working exclusively on the FastAPI/Python application in the `backend/` directory.

## Scope & Boundaries

- **ONLY work in**: `backend/` directory
- **NEVER modify**: `frontend/`, `scripts/`, `prisma/`, `sql/`, or any TypeScript/JavaScript files
- **If frontend changes needed**: Document API changes, do NOT modify frontend code

## Technology Stack

- **Framework**: FastAPI 0.104.0+
- **Python**: 3.11+
- **Database**: PostgreSQL 16 (via psycopg2)
- **Validation**: Pydantic 2.0+
- **Async**: asyncio, async/await patterns
- **Connection Pooling**: psycopg2 ThreadedConnectionPool

## Code Style & Structure

### File Organization
- Main app: `app/main.py`
- API routes: `app/api/v1/`
- Schemas: `app/schemas/`
- Utilities: `app/utils/`
- Database: `app/database.py`
- Config: `app/config.py`

### Naming Conventions
- Files: snake_case (e.g., `customer_behavior.py`)
- Functions: snake_case (e.g., `get_customer_demographics`)
- Classes: PascalCase (e.g., `Database`, `Settings`)
- Constants: UPPER_SNAKE_CASE

### Python Type Hints
- **REQUIRED**: All functions must have type hints
- Use Pydantic models for request/response validation
- Explicit return types: `async def function() -> ResponseModel:`
- No `Any` type - use specific types or `Union`/`Optional`
- Use `from typing import Optional, List, Dict, Union`

## FastAPI Patterns

### Router Structure
- Each domain has its own router in `app/api/v1/`
- Routers are included in `main.py` with prefixes
- Use tags for OpenAPI documentation

### Endpoint Patternn
@router.get("/endpoint", response_model=AnalyticsResponse)
async def get_endpoint(
    filters: UniversalFilter = Depends(get_filters),
):
    """Endpoint description."""
    where_clause, params = build_where_clause(filters)
    
    query = """
        SELECT ...
        FROM table
        WHERE {where_clause}
    """
    
    results = db.execute_query(query, tuple(params))
    
    return AnalyticsResponse(
        data=results,
        metadata={"count": len(results)},
        filters_applied=filters,
    )### Dependencies
- Use FastAPI `Depends()` for dependency injection
- Common dependencies in `app/api/dependencies.py`
- Filter parsing: `get_filters` dependency

## Database Patterns

### Connection Management
- Use `Database` class from `app/database.py`
- Access via `db.execute_query(query, params)`
- Always use parameterized queries (never string formatting)
- Use context managers for transactions

### Query Patterns
- Use `build_where_clause()` from `app/utils/filters.py`
- Always use parameterized queries to prevent SQL injection
- Handle NULL values explicitly with `IS NULL` checks
- Use JOINs instead of N+1 queries

### Example Query
where_clause, params = build_where_clause(filters)

query = f"""
    SELECT 
        column1,
        column2,
        COUNT(*) as count
    FROM table t
    WHERE {where_clause}
    GROUP BY column1, column2
    ORDER BY count DESC
    LIMIT 100
"""

results = db.execute_query(query, tuple(params))
## Pydantic Models

### Request/Response Models
- Located in `app/schemas/`
- Use for all API request/response validation
- Inherit from `BaseModel`
- Use field validators when needed

### Example Schema
from pydantic import BaseModel
from typing import Optional

class UniversalFilter(BaseModel):
    branch_id: Optional[str] = None
    date_from: Optional[str] = None
    date_to: Optional[str] = None
    # ... other fields## Error Handling

### Exception Handling
- Use FastAPI's `HTTPException` for API errors
- Global exception handler in `main.py`
- Log errors appropriately
- Return user-friendly error messages
- Never expose internal errors to clients

### Error Response Pattern
from fastapi import HTTPException

if not result:
    raise HTTPException(
        status_code=404,
        detail="Resource not found"
    )## Async/Await

### All Endpoints Must Be Async
- Use `async def` for all route handlers
- Use `await` for database operations
- Use async context managers when available

### Database Operations
- Database class handles async connection pooling
- Use `db.execute_query()` which is thread-safe
- Don't block the event loop

## API Response Format

### Standard Response
All endpoints return `AnalyticsResponse`:
return AnalyticsResponse(
    data=results,  # The actual data
    metadata={"count": len(results)},  # Additional metadata
    filters_applied=filters,  # Applied filters
)
### Response Model
class AnalyticsResponse(BaseModel):
    data: Any
    metadata: Dict[str, Any] = {}
    filters_applied: UniversalFilter
    timestamp: Optional[str] = None
    cache_ttl: Optional[int] = None## Filter Handling

### Universal Filter
- All endpoints accept `UniversalFilter` via dependency injection
- Use `build_where_clause()` to convert filters to SQL
- Handle date ranges, branch filters, sales person filters, etc.
- Always validate filter inputs

### Filter Building
from ...utils.filters import build_where_clause

where_clause, params = build_where_clause(filters)
# where_clause: "column1 = %s AND column2 = %s"
# params: ["value1", "value2"]## Configuration

### Settings
- Use Pydantic Settings from `app/config.py`
- Access via `settings.database_url`, `settings.cors_origins`, etc.
- Environment variables loaded from `.env`

### CORS
- Configured in `main.py`
- Uses `settings.cors_origins`
- Allows credentials

## Logging

- Use Python's `logging` module
- Configure appropriate log levels
- Log errors, warnings, and important operations
- Don't log sensitive data (passwords, tokens)

## Testing Considerations

- Endpoints should be testable
- Use dependency injection for testability
- Mock database connections in tests
- Test error cases

## Performance

### Database Optimization
- Use indexes on frequently queried columns
- Avoid N+1 queries (use JOINs)
- Use LIMIT clauses for large result sets
- Consider pagination for large datasets

### Query Optimization
- Use EXPLAIN ANALYZE to optimize queries
- Avoid SELECT * when possible
- Use appropriate JOIN types
- Index foreign keys

## Security

### SQL Injection Prevention
- **ALWAYS** use parameterized queries
- **NEVER** use string formatting for SQL
- Use `build_where_clause()` utility

### Input Validation
- Use Pydantic models for validation
- Validate all user inputs
- Sanitize filter parameters

## Common Patterns

### Router Definition
from fastapi import APIRouter

router = APIRouter()

@router.get("/endpoint")
async def endpoint():
    ...### Database Querython
from ...database import db

query = "SELECT * FROM table WHERE id = %s"
results = db.execute_query(query, (id_value,))### Response Buildinghon
return AnalyticsResponse(
    data=results,
    metadata={"count": len(results)},
    filters_applied=filters,
)## DO NOT

- ❌ Modify frontend code
- ❌ Use string formatting for SQL queries
- ❌ Skip type hints
- ❌ Use synchronous database operations
- ❌ Expose internal errors to clients
- ❌ Hardcode configuration values
- ❌ Create endpoints without Pydantic validation
- ❌ Forget to handle NULL values in queries
- ❌ Create N+1 query problems
- ❌ Skip error handling
```

