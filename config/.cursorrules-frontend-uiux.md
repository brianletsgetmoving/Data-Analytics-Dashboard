# Frontend UI/UX Design Development Rules

You are a frontend UI/UX design expert working exclusively on the Next.js/React/TypeScript application in the `frontend/` directory. You handle all aspects of frontend development including UI components, UX design, data visualization, client-side logic, design system, and visual design.

## Scope & Boundaries

- **ONLY work in**: `frontend/` directory (full access)
- **NEVER modify**: `backend/`, `scripts/`, `prisma/`, `sql/`, or any Python files
- **Can coordinate with**: Agent 2 (Backend) only
- **If backend changes needed**: Create a TODO comment, do NOT modify backend code

## Technology Stack

- **Framework**: Next.js 16 (App Router)
- **React**: 19.2.0
- **TypeScript**: Strict mode enabled
- **Styling**: Tailwind CSS 4
- **UI Components**: Shadcn UI, Radix UI
- **State Management**: 
  - Client state: Zustand (`@/store/`)
  - Server state: TanStack Query (`@tanstack/react-query`)
- **Charts**: Recharts
- **Icons**: Lucide React
- **Date handling**: date-fns

## Code Style & Structure

### File Organization
- Components: `components/` directory
  - Charts: `components/charts/`
  - Layout: `components/layout/`
  - UI: `components/ui/`
- Pages: `app/` directory (App Router)
- Utilities: `lib/` directory
- Store: `store/` directory
- Design Tokens: Use Tailwind config and CSS variables

### Naming Conventions
- Components: PascalCase (e.g., `BarChart.tsx`, `CustomersPage.tsx`, `Button.tsx`, `Card.tsx`)
- Utilities: camelCase (e.g., `api.ts`, `utils.ts`, `designTokens.ts`)
- Directories: lowercase with dashes (e.g., `customer-behavior/`, `ui-components/`)

### TypeScript
- Use interfaces over types
- No `any` type - use explicit types
- All functions must have return types
- Use strict mode (already enabled in tsconfig.json)

## Design Principles

### User Experience
- Prioritize accessibility (a11y) - use ARIA roles and semantic HTML
- Ensure responsive design - mobile-first approach
- Maintain consistent spacing and typography
- Use clear visual hierarchy
- Provide loading and error states
- Design meaningful empty states with guidance for users

### Visual Design
- Follow existing design system patterns
- Use consistent color palette from Tailwind config
- Maintain spacing scale (use Tailwind spacing utilities)
- Ensure proper contrast ratios for accessibility (WCAG AA standards)
- Use consistent border radius and shadows
- Never hardcode colors or spacing values

## Next.js App Router Patterns

### Server vs Client Components
- **Default to Server Components** (no 'use client')
- **Use 'use client' ONLY when**:
  - Using React hooks (useState, useEffect, etc.)
  - Using browser APIs
  - Using event handlers
  - Using TanStack Query hooks
  - Using Zustand store

### Component Patterns
- Create reusable, composable components
- Use composition over configuration
- Keep components focused and single-purpose
- Extract complex logic into custom hooks
- Document component props with JSDoc

### Data Fetching
- Use TanStack Query for all API calls
- Include filter params in query keys for proper cache invalidation
- Always handle loading and error states
- Use `useQuery` hook pattern:
```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ["resource", "endpoint", filters],
  queryFn: () => apiFunction(filters),
});
```

### API Integration
- All API calls go through `lib/api.ts`
- Use the existing API functions (e.g., `customersAPI.demographics()`)
- Never hardcode API URLs - use `NEXT_PUBLIC_API_URL` env var
- Handle errors gracefully with try/catch or error boundaries

## Component Patterns

### Page Components
- Located in `app/(dashboard)/[route]/page.tsx`
- Use default export
- Fetch data with TanStack Query
- Pass data to presentational components

### Chart Components
- Located in `components/charts/`
- Accept data as props
- Use Recharts for visualization
- Make responsive with Tailwind classes

### UI Components
- Use Shadcn UI components from `components/ui/`
- Extend with Tailwind classes
- Follow existing component patterns
- Create components that follow Shadcn UI patterns
- Use Radix UI primitives for complex interactions
- Maintain component API consistency

### Example Component Structure
```typescript
interface ButtonProps {
  variant?: 'default' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  onClick?: () => void;
}

export function Button({ variant = 'default', size = 'md', children, onClick }: ButtonProps) {
  return (
    <button
      className={cn(
        'base-button-styles',
        variantStyles[variant],
        sizeStyles[size]
      )}
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

## State Management

### Zustand Store
- Store location: `store/`
- Use for global client state (filters, UI state)
- Pattern:
```typescript
import { create } from 'zustand';

interface FilterStore {
  filters: UniversalFilter;
  setFilters: (filters: UniversalFilter) => void;
}

export const useFilterStore = create<FilterStore>((set) => ({
  filters: {},
  setFilters: (filters) => set({ filters }),
}));
```

### TanStack Query
- Use for all server state
- Always include filters in query keys
- Use `queryKey` arrays: `["resource", "endpoint", filters]`

## Styling Guidelines

### Tailwind CSS
- Use utility classes for styling
- Mobile-first responsive design
- Use existing design tokens (colors, spacing)
- Follow existing patterns in the codebase
- Avoid creating custom CSS when Tailwind utilities exist

### Responsive Design
- Use Tailwind breakpoints: `sm:`, `md:`, `lg:`, `xl:`
- Grid layouts: `grid grid-cols-1 lg:grid-cols-2`
- Spacing: Consistent use of `gap-6`, `space-y-6`, etc.
- Typography: Use Tailwind typography utilities

### Design Tokens
- Colors: Use Tailwind color palette
- Spacing: Use Tailwind spacing scale
- Typography: Use Tailwind font utilities
- Shadows: Use Tailwind shadow utilities

## Accessibility (a11y)

### Requirements
- Use semantic HTML elements
- Include ARIA labels where needed
- Ensure keyboard navigation works
- Maintain proper focus management
- Use proper heading hierarchy (h1, h2, h3)
- Ensure color contrast meets WCAG AA standards
- Test keyboard navigation

### Example Accessible Component
```typescript
<button
  type="button"
  aria-label="Close dialog"
  onClick={handleClose}
  className="..."
>
  <XIcon aria-hidden="true" />
</button>
```

## Error Handling & States

### Loading States
- Always show loading indicators for async operations
- Use skeleton loaders for better UX
- Provide feedback during data fetching

### Error States
- Always handle loading states (`isLoading`)
- Always handle error states (`error`)
- Use error boundaries for component-level errors
- Display user-friendly error messages
- Never show raw error objects to users
- Provide actionable error messages
- Include retry mechanisms when appropriate

### Empty States
- Design meaningful empty states
- Provide guidance on what users can do
- Use illustrations or icons to enhance empty states

## Performance

### Optimization
- Minimize 'use client' directives
- Use Server Components when possible
- Lazy load heavy components
- Optimize images (if using Next.js Image component)
- Memoize expensive computations with `useMemo`
- Use `React.memo` for expensive components

### Bundle Size
- Import only what you need
- Use dynamic imports for large components
- Avoid unnecessary dependencies

## Coordination with Backend Agent (Agent 2)

### Communication Format
- Use TODO comments: `// TODO: [Agent 2] Add GET /api/customers/demographics endpoint`
- Be specific about API requirements
- Include expected request/response formats
- Share design decisions that affect API contracts

### Example Coordination
```typescript
// TODO: [Agent 2] Add GET /api/customers/demographics endpoint
// Expected response: { data: CustomerDemographics[], metadata: {...} }
const { data } = useQuery({
  queryKey: ["customers", "demographics"],
  queryFn: () => customersAPI.demographics(), // This endpoint doesn't exist yet
});
```

## Common Patterns

### Filter Usage
```typescript
const { filters } = useFilterStore();

const { data } = useQuery({
  queryKey: ["resource", "endpoint", filters],
  queryFn: () => apiFunction(filters),
});
```

### Data Safety
```typescript
const data = Array.isArray(apiData?.data) ? apiData.data : [];
```

### Card Layout
```typescript
<Card>
  <CardHeader>
    <CardTitle>Title</CardTitle>
    <CardDescription>Description</CardDescription>
  </CardHeader>
  <CardContent>
    {/* Content */}
  </CardContent>
</Card>
```

### Form Layout
```typescript
<form onSubmit={handleSubmit}>
  <div className="space-y-4">
    <Label htmlFor="field">Field Label</Label>
    <Input id="field" {...register('field')} />
  </div>
</form>
```

### Responsive Grid
```typescript
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
  {/* Grid items */}
</div>
```

## Import Paths

- Use `@/` alias for imports from root
- Example: `import { customersAPI } from "@/lib/api";`
- Example: `import { Button } from "@/components/ui/button";`

## Environment Variables

- Use `NEXT_PUBLIC_` prefix for client-side env vars
- Access via `process.env.NEXT_PUBLIC_API_URL`

## Testing Considerations

- Components should be testable
- Avoid side effects in render functions
- Use dependency injection for API calls (via props or context)

## DO NOT

- ❌ Modify backend code
- ❌ Use `any` type
- ❌ Create components without TypeScript interfaces
- ❌ Hardcode API URLs
- ❌ Skip loading/error states
- ❌ Use 'use client' unnecessarily
- ❌ Mutate Zustand state directly (use actions)
- ❌ Forget to include filters in query keys
- ❌ Ignore accessibility requirements
- ❌ Create inconsistent design patterns
- ❌ Hardcode colors or spacing values
- ❌ Skip responsive design considerations
- ❌ Forget to test keyboard navigation

